<?xml version="1.0" encoding="Shift_JIS"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<!-- generated by to_html.pl from dictionary.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS" />
	<title>Dictionary クラス</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="吉里吉里関連リファレンス用標準スタイル" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="トップページ" />
</head>
<body>
<h1><a id="id72" name="id72">Dictionary クラス</a>
</h1><div class="para"><div>
　Dictionary クラスは<a id="id73" name="id73" class="targanchor"><dfn>辞書配列</dfn></a>を扱うクラスです。<br />
<br />
　辞書配列は<a id="id74" name="id74" class="targanchor"><dfn>連想配列</dfn></a>とも呼ばれ、名前と、それに結びつけられた値を一つのペアとして、それを複数保持するオブジェクトです。<br />
　配列と同じように <a id="id75" name="id75" class="targanchor"><dfn>[ ]</dfn></a> (間接参照) 演算子でアクセスしますが、添え字の代わりに文字列を使い、それが名前となります。名前が識別子として有効なものであれば、 <a id="id76" name="id76" class="targanchor"><dfn>.</dfn></a> (直接参照) 演算子も使うことができます。<br />
　また、存在しない名前を参照すると void になります。<br />
　要素を削除するには delete 演算子を使います。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;d=new&nbsp;Dictionary();<br />
&nbsp;&nbsp;&nbsp;&nbsp;d[&quot;sat&quot;]&nbsp;=&nbsp;1;&nbsp;<span class="comment">//&nbsp;d.sat&nbsp;=&nbsp;1&nbsp;と同じ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;d[&quot;sun&quot;]&nbsp;=&nbsp;2;&nbsp;<span class="comment">//&nbsp;d.sun&nbsp;=&nbsp;2&nbsp;と同じ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;d[&quot;mon&quot;]&nbsp;=&nbsp;3;&nbsp;<span class="comment">//&nbsp;d.mon&nbsp;=&nbsp;3&nbsp;と同じ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;d[&quot;name&quot;]&nbsp;=&quot;value!&quot;;&nbsp;<span class="comment">//&nbsp;d.name&nbsp;=&nbsp;&quot;value!&quot;&nbsp;と同じ</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;d[&quot;continue&quot;]&nbsp;=&nbsp;4;&nbsp;<span class="comment">//&nbsp;continue&nbsp;は識別子ではないが&nbsp;OK</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;d.continue&nbsp;=&nbsp;4;&nbsp;<span class="comment">//&nbsp;continue&nbsp;は識別子ではないのでエラー</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;sat&nbsp;=&nbsp;d[&quot;sat&quot;];&nbsp;<span class="comment">//&nbsp;1&nbsp;が代入される</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;none&nbsp;=&nbsp;d[&quot;none&quot;];&nbsp;<span class="comment">//&nbsp;void&nbsp;が代入される</span><br />
<br />
&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;d.sat;&nbsp;<span class="comment">//&nbsp;sat&nbsp;を削除</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;d[&quot;continue&quot;];&nbsp;<span class="comment">//&nbsp;continue&nbsp;を削除</span><br />
</code>
<br />

<br />
</div></div>

<h1><a id="id77" name="id77">式中辞書配列</a>
</h1><div class="para"><div>
　<code class="inlinecode"><a id="id78" name="id78" class="targanchor"><dfn>%[ ]</dfn></a></code> を使って、式中に <code class="inlinecode">Dictionary</code> クラスのオブジェクトをその場で記述することができます。要素名 =&gt; 要素の値、をカンマで区切り、初期要素となる式を列挙します。たとえば、<br />
<code class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;var dic = %[&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3];<br />
</code>　と記述すれば、<code class="inlinecode">dic</code> に、要素名と要素の組がそれぞれ <code class="inlinecode">&quot;a&quot;:1</code>、 <code class="inlinecode">&quot;b&quot;:2</code>、 <code class="inlinecode">&quot;c&quot;:3</code>  となる <code class="inlinecode">Dictionary</code> クラスのオブジェクトへの参照が代入されます。<br />
　内部的には、<code class="inlinecode">=&gt;</code> はカンマと全く同じものですが、読みやすさを考え、<code class="inlinecode">=&gt;</code> を使用できるようになっています ( perl と同じです )。<br />
</div></div>
<h1><a id="id79" name="id79">Dictionary クラスのメソッドへのアクセス</a>
</h1><div class="para"><div>
　Dictionary クラスのオブジェクトは、作成された状態ではメンバを何一つ持っていません。<br />
　たとえば、assign メソッドを使おうと思って、Dictionary クラスのオブジェクト dict に対して<code class="inlinecode">dict.assign(src)</code> のように記述しても、dict が assign というメソッドを持っていないためにエラーになります。<br />
　したがって、<a id="id80" name="id80" class="targanchor"><dfn>incontextof</dfn></a> 演算子を使って、Dictionary クラスに直接属しているメソッドを、対象となる Dictionary クラスのオブジェクトをコンテキストとして実行させます。<br />

<br />
<code class="bq"><span class="weak">例:</span><br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;a&nbsp;=&nbsp;%[];<br />
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;b&nbsp;=&nbsp;%[];<br />
&nbsp;&nbsp;&nbsp;&nbsp;(Dictionary.assign&nbsp;incontextof&nbsp;a)(b);&nbsp;<span class="comment">//&nbsp;b&nbsp;を&nbsp;a&nbsp;にコピー</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;(Dictionary.clear&nbsp;incontextof&nbsp;b)();&nbsp;<span class="comment">//&nbsp;b&nbsp;の内容をクリア</span><br />
</code>
<br />

</div></div>
<h1><a id="id81" name="id81">saveStruct</a>
</h1><div class="para"><div>
　saveStruct はファイルへ構造化されたデータの出力を行います。<br />
　<a target="main" class="jump" href="array.html">Array クラス</a> の同メソッド参照してください。<br />
</div></div>
<h1><a id="id82" name="id82">assign</a>
</h1><div class="para"><div>
　assign メソッドは、辞書配列をコピーします。<br />

<br />
<code class="bq">構文&nbsp;:&nbsp;assign(&lt;コピー元辞書配列&gt;,&nbsp;&lt;内容をクリアするか=true&gt;)<br />
</code>
<br />

　引数で指定された他の辞書配列の内容を、そっくりコピーします。<br />
　「内容をクリアするか」が偽の場合は、コピー先 (メソッドを実行するオブジェクト) の内容をクリアせず、コピー元辞書配列の内容を上書きします。コピー元辞書配列と同じ名前のメンバがコピー先辞書配列にあった場合は、コピー元の内容でコピー先が上書きされます。<br />
<br />
　配列 (Arrayクラスのオブジェクト) をコピー元配列に指定した場合は、その配列には、この辞書配列のメンバとなるべき要素が名前、値の順に並んでいるとみなし、その配列の内容をこの辞書配列にコピーします。<br />
</div></div>
<h1><a id="id83" name="id83">assignStruct</a>
</h1><div class="para"><div>
　assignStruct メソッドは、辞書配列をコピーします。<br />

<br />
<code class="bq">構文&nbsp;:&nbsp;assignStruct(&lt;コピー元辞書配列&gt;)<br />
</code>
<br />

　引数で指定された他の辞書配列の内容を、そっくりコピーします。<br />
　assign メソッドと違い、メンバに配列あるいは辞書配列があった場合は、再帰的にその内容も
コピーします ( assign メソッドの場合は参照がコピーされるだけです )。<br />
</div></div>
<h1><a id="id84" name="id84">clear</a>
</h1><div class="para"><div>
　clear メソッドは、辞書配列の内容をすべて消去します。<br />
</div></div>

	<script type="text/javascript" charset="Shift_JIS" src="documentid.js" ></script>
	<script type="text/javascript" charset="Shift_JIS" src="postcontent.js" ></script>
</body>
</html>
